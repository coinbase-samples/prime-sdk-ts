/**
 * Copyright 2024-present Coinbase Global, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fs = require('fs');
const path = require('path');
const prettier = require('prettier');

// Source and destination directories
const parentDir = './types';
const sourceDir = './types/model';
const destDir = './types/processed';
const destDirEnums = './types/processed/enums';
const indexPath = path.join(destDir, 'index.ts');
const enumIndexPath = path.join(destDirEnums, 'index.ts');

const filePathReplacements = {
  coinbaseCustodyApiActivityType: 'CustodyActivityType',
  coinbasePublicRestApiActivityType: 'PrimeActivityType',
  CoinbasePublicRestApi: '',
  coinbasePublicRestApi: '',
  PrimeRESTAPI: '',
  primeRESTAPI: '',
  CoinbaseCustodyApi: '',
  coinbaseCustodyApi: '',
  rFQ: 'RFQ',
  CoinbaseBrokerageProxyEventsMaterializedApi: '',
  coinbaseBrokerageProxyEventsMaterializedApi: '',
  publicRestApi: '',
  PublicRestApi: '',
};

const skipFiles = [
  'changeOnchainAddressGroupRequestIsARequestToCreateOrUpdateANewOnchainAddressGroup.ts',
  'changeOnchainAddressGroupRequestIsARequestToCreateOrUpdateANewOnchainAddressGroup1.ts',
  'googleProtobufAny.ts',
  'googleRpcStatus.ts',
];

// Replace specific strings
const replacements = {
  '<any>': '',
  "\nimport { RequestFile } from './models';\n": '',
  'static discriminator: string | undefined = undefined;\n\n': '',
  coinbaseCustodyApiActivityType: 'CustodyActivityType',
  coinbasePublicRestApiActivityType: 'PrimeActivityType',
  CoinbasePublicRestApi: '',
  coinbasePublicRestApi: '',
  PrimeRESTAPI: '',
  primeRESTAPI: '',
  CoinbaseCustodyApi: '',
  coinbaseCustodyApi: '',
  CoinbaseBrokerageProxyEventsMaterializedApi: '',
  coinbaseBrokerageProxyEventsMaterializedApi: '',
  publicRestApi: '',
  PublicRestApi: '',
};

const classnameAsExceptions = ['CustodyActivityType', 'PrimeActivityType'];

const prettierConfig = {
  semi: true,
  singleQuote: true,
  trailingComma: 'es5',
  parser: 'typescript',
};

// Ensure the destination directory exists
if (!fs.existsSync(parentDir)) {
  fs.mkdirSync(parentDir, { recursive: true });
}

if (!fs.existsSync(destDir)) {
  fs.mkdirSync(destDir, { recursive: true });
} else {
  fs.rmSync(destDir, { recursive: true });
}

if (!fs.existsSync(destDirEnums)) {
  fs.mkdirSync(destDirEnums, { recursive: true });
}

// Function to replace specific strings
function replaceString(content, replacements) {
  let updatedContent = content;
  for (const [search, replace] of Object.entries(replacements)) {
    updatedContent = updatedContent.split(search).join(replace);
  }
  return updatedContent;
}

function cleanClasses(updatedContent) {
  updatedContent = updatedContent.replace(
    /export class (\w+) \{/g,
    (match, className) => {
      return `export type ${className} = {`;
    }
  );
  // Regular expression to match the function definition and body:
  // - Handles modifiers (async, public, private, etc.)
  // - Matches the function name and parameters
  // - Captures the entire function body, including the curly braces
  let functionName = 'attributeTypeMap';
  let regex = new RegExp(
    `\\s*(?:async|public|private|protected|static|\\s)*${functionName}\\s*(?:<.*?>)?\\s*\\(.*?\\)\\s*(?::\\s*[^=\\{]+)?\\s*\\{[\\s\\S]*?\\}|` + // Matches function definitions
      `\\s*static\\s+${functionName}\\s*:\\s*[^=]+=\\s*\\[[\\s\\S]*?\\];`,
    'g'
  );

  // Remove the function calls from the content
  updatedContent = updatedContent.replace(regex, '');

  functionName = 'getAttributeTypeMap';
  regex = new RegExp(
    `\\s*(?:async|public|private|protected|static|\\s)*${functionName}\\s*(?:<.*?>)?\\s*\\(.*?\\)\\s*(?::\\s*[^=\\{]+)?\\s*\\{[\\s\\S]*?\\}|` + // Matches function definitions
      `\\s*static\\s+${functionName}\\s*:\\s*[^=]+=\\s*\\[[\\s\\S]*?\\];`,
    'g'
  );

  // Remove the function calls from the content
  updatedContent = updatedContent.replace(regex, '');

  regex = /^\s*export\s+namespace\s+\w+\s*\{\s*\}/gm;

  // Remove lines containing namespace
  updatedContent = updatedContent.replace(regex, '');
  return updatedContent;
}

function addGeneratedHeader(updatedContent) {
  const header = `/**
 * Copyright 2025-present Coinbase Global, Inc.
 *
 * This file is generated by Openapi Generator https://github.com/openapitools/openapi-generator
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 *  Do not edit the class manually.
 */
 `;
  return header + updatedContent;
}

function getIndexFileExport(destPath, updatedContent) {
  const fileName = destPath
    .replace('types/processed/', '')
    .replace('types/processed/enums/', '')
    .replace('.ts', '');

  const isEnum = destPath.includes('enum');
  const baseName = fileName.replace('enums/', '');
  let typeName = '';

  if (isEnum) {
    const typeMatch = updatedContent.match(/export\s+enum\s+(\w+)\s*/);
    if (!typeMatch) throw new Error(`No enum name found in file: ${fileName}`);

    // handle export with as syntax for namespace collisions
    if (classnameAsExceptions.includes(baseName)) {
      typeName = `${typeMatch[1]} as ${baseName}`;
    } else {
      typeName = typeMatch[1];
    }

    return `export { ${typeName} } from './${baseName}';`;
  } else {
    const typeMatch = updatedContent.match(/export\s+type\s+(\w+)\s*=/);
    if (!typeMatch)
      throw new Error(
        `No type name found in file: ${fileName} destPath: ${destPath}`
      );

    typeName = typeMatch[1];
    return `export type { ${typeName} } from './${baseName}';`;
  }
}

// Main function to process files
async function processFiles() {
  // List all files in the source directory
  const files = fs.readdirSync(sourceDir);
  const indexFileContent = [];
  const enumIndexFileContent = [];

  const enumClasses = [];
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const sourcePath = path.join(sourceDir, file);
    if (fs.statSync(sourcePath).isFile()) {
      const content = fs.readFileSync(sourcePath, 'utf8');
      const isEnum = content.indexOf('enum') > 0;
      if (isEnum) {
        const filePath = replaceString(
          path.join(destDirEnums, file),
          filePathReplacements
        );
        const enumName = filePath
          .replace('types/processed/enums/', '')
          .replace('.ts', '');
        console.log('processed enum', enumName, filePath);
        enumClasses.push(enumName);
      }
    }
  }

  for (let j = 0; j < files.length; j++) {
    const file = files[j];
    const sourcePath = path.join(sourceDir, file);
    let destPath = path.join(destDir, file);

    if (skipFiles.includes(file)) {
      console.log('skipping file', file);
      continue;
    }

    // Read each file (synchronously or asynchronously)
    if (fs.statSync(sourcePath).isFile()) {
      const content = fs.readFileSync(sourcePath, 'utf8');
      const isEnum = content.indexOf('enum') > 0;

      let updatedContent = replaceString(content, replacements);

      if (updatedContent.indexOf('class') > 0) {
        updatedContent = cleanClasses(updatedContent);
      }

      // Remove the generated multiline comment header
      let regex = /\/\*[\s\S]*?\*\//;
      updatedContent = updatedContent.replace(regex, '');

      // Regular expression to match specific import statements
      regex = /import\s+\{[^}]+\}\s+from\s+'\.\/(.*?)';/g;

      // Replace the import paths with the updated path
      updatedContent = updatedContent.replace(regex, (match, importPath) => {
        if (enumClasses.includes(importPath)) {
          return `import { ${match
            .split('{')[1]
            .split('}')[0]
            .trim()} } from './enums/${importPath}';`;
        } else {
          return `import { ${match
            .split('{')[1]
            .split('}')[0]
            .trim()} } from './${importPath}';`;
        }
      });

      if (isEnum) {
        destPath = replaceString(
          path.join(destDirEnums, file),
          filePathReplacements
        );
        enumIndexFileContent.push(getIndexFileExport(destPath, updatedContent));
      } else {
        destPath = replaceString(destPath, filePathReplacements);
        indexFileContent.push(getIndexFileExport(destPath, updatedContent));
      }

      updatedContent = addGeneratedHeader(updatedContent);

      updatedContent = await prettier.format(updatedContent, prettierConfig);

      if (fs.existsSync(destPath)) {
        console.log('file already exists: ', destPath);
      }

      // Write the updated content to the destination directory
      fs.writeFileSync(destPath, updatedContent, 'utf8');

      console.log(`Processed: ${file} at ${destPath}`);
    }
  }

  // Write to index.ts
  fs.writeFileSync(indexPath, indexFileContent.join('\n') + '\n');
  fs.writeFileSync(enumIndexPath, enumIndexFileContent.join('\n') + '\n');

  console.log('All files processed.');
}

// Execute the script
processFiles().then(() => {
  console.log('Processing complete.');
});
